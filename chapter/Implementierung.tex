\chapter{\label{chap:implementierung}Der Prototyp}
In diesem Kaptitel wird die nach dem in Kapitel \ref{chap:entwurf} präsentierten Lösungswegs die detaillierte Beschreibung der technischen Realisierung der Anwendung vorgestellt.\\
Nach der Erklärung der Konfigurationsdateien wird auf die Umsetzung der Szenarien eingegangen. Im Zuge dessen werden die implementierten Algorithmen vorgestellt, wobei sich der erste mit dem Auffinden der nächsten relevanten Ampel befasst und der zweite die empfohlene Geschwindigkeit berechnet.
\section{Die Manifest- und build.gradle-Datei}
Das Android-Manifest dient der Festlegung wichtiger Eigenschaften der Anwendung und gehört zu jedem Android-Projekt. (+ gradle...)\\

Die \gls{XML}-Datei (\texttt{AndroidManifest.xml}) ist im Hauptverzeichnis des Projekts zu finden und ist im Listing \ref{lst:manifest} abgebildet. \\
In der zweiten Zeile wird hier der Paketname des Programms festgelegt. 
Im \texttt{application}-Tag werden Variablen gesetzt, die das in dargestellte Icon und den Namen der Anwendung definieren. Darüber hinaus wird hier die \gls{Activity} der Applikation definiert. Zuerst wird der Name der \gls{Activity} gesetzt. Die Variable \texttt{screenOrientation} legt das Format der Anzeige fest und verhindert ein automatisches Drehen des Bildschirms. Im \texttt{intent-filter}-Tag dass diese Activity beim Start der App ausgeführt wird. Hätte die Anwendung über mehrere \glspl{Activity} implementiert, würden die anderen ebenfalls hier aufgeführt werden.\\
Unterhalb des \texttt{application}-Tags, in Zeile 17, werden nun die Berechtigung des \gls{GPS}-Zugriffs der Applikation, um Standortdaten, also die jeweiligen geographischen Kordinaten des Endgeräts zu beziehen gesetzt.
\begin{center}
\rule{35em}{0.5pt} \lstinputlisting[language=XML, firstline=2, lastline=21, caption={AndroidManifest.xml}, label=lst:manifest]{code/manifest.xml}
 \rule{35em}{0.5pt}
\end{center}
Für welche Android Versionen die Anwendung geschrieben wurde (\texttt{targetSdkVersion}) und das minimale \gls{API}-Level der Anwendung, also unter welcher Version die App noch ausgeführt werden kann:
\begin{center}
\rule{35em}{0.5pt} \lstinputlisting[language=JSON, firstline=6, lastline=14,  caption={Auszug aus der build.gradle-Datei}, label=lst:gradle]{code/build.gradle} \rule{35em}{0.5pt}
\end{center}
Hier wird der Name der \gls{Activity}-Klasse gesetzt und im \texttt{intent-filter}-Tag festgelegt, dass diese \gls{Activity} als \texttt{MainActivity} beim Start der Anwendung ausgeführt wird. 
%
% MainActivity
%
\section{MainActivity-Klasse}
Die Klasse \texttt{MainActivity} ist die \gls{Activity}, die beim Start der Anwendung ausgeführt wird.  Hier werden die Anzeigeelemente initialisiert und die zentralen Funktionalitäten implementiert \textit{, bzw. delegiert}.\\
Die Methode \texttt{onCreate} ist die erste Methode im \gls{Activity}-Lebenszyklus\footnote{ \url{http://developer.android.com/training/basics/activity-lifecycle/starting.html} -- Zugriff: 02.03.2015} und wird direkt nach dem Start der \gls{Activity} ausgeführt. Hier werden die Anzeigeelemente gesetzt und nach jeder Installation ein Dialog erstellt, der auf die oberste Priorität der Straßenverkehrsordnung hinweist.\\
Es wird eine Instanz des \texttt{JSONParser}-Objekts erstellt, welche die \gls{JSON}-Datei aus dem Ressourcenordner liest und in ein Objektarray umwandelt. Neben der \texttt{SpeedHandler}-Objektinstanz, welche für die Geschwindigkeitsempfehlung und dessen Anzeige zuständig ist, wird die des \texttt{GPSTracker} erstellt. Auf diesen ist der \texttt{OnSetListener} registriert, welcher ein Ereignis wirft sobald er die nächstgelegende Ampel gesetzt hat. Sobald dieser Fall eingetreten ist, wird der \texttt{SpeedHandler} beauftragt, den dazugehörigen Signalschaltplan zu holen, um dann anhand dieser Daten die Berechnungen durchzuführen und deren Ergebnisse anzuzeigen.   
%
% Umsetzung Szenarien
%
\section{Umsetzung Szenarien}
Wie in Kapitel \ref{chap:szenarien} beschrieben, lassen sich die sieben möglichen Szenarien auf insgesamt fünf komprimieren, da die Szenarien R2 und G2, genauso wie die Szenarien R3 und G3 dasselbe Ergebnis haben. Die zusammengefassten fünf Szenarien eignen sich für eine prototypische Umsetzung, welche im Folgenden beschrieben wird.
\subsection{?Einlesen der Ampeldaten?}
Neben der Geräteposition bilden die Ampelposition und deren Signalschaltpläne die Grundlage der Anwendung. Hierbei ost das korrekte Einlesen und Auswerten der Daten obligatorisch. Die Aufgabe des \texttt{JSONParsers} ist es also, die manuell erstellte \gls{JSON}-Datei, welche die Ampeldaten beinhaltet, richtig zu konvertieren.  Die Klasse \texttt{JSONParser} liest also die Datei ein und wandelt dann die enthaltenen \gls{JSON}-Ampelobjekte in Java-Ampelobjekte um.\\ 
Hierfür wird das \gls{JSON}-Array durchlaufen und für jedes enthaltende Objekt ein Ampelobjekt erzeugt. Aus den Werten \texttt{lat} und \texttt{lon}, stehend für latitude und longitude, wird ein \texttt{Location}-Objekt erzeugt, das als Attribut gesetzt wird. Der boolsche Wert \texttt{dependsOnTraffic} ist auf \texttt{true} gesetzt, sobald die \gls{LSA} verkehrsabhängig ist. Ist dies der Fall, ist eine Vorhersage der Ampel aufgrund beeinflussender Parameter nicht möglich und es wird ein Objekt mit den beiden genannten Attributen und dem bezeichnenden Namensattribut erzeugt. Andernfalls werden die zu der Ampel hinzugehörigen Schaltpläne durchlaufen und für jeden ein selbiges Objekt erzeugt, welche in einem Array gespeichert dem Ampelobjekt als weiteres Attribut übergeben wird. Es ist zu beachten, dass jeder Signalschaltplan über ein Array mit Tagen verfügt. Denn ein Schaltplan kann an mehreren Tagen gültig sein. Die Tage sind als Strings gespeichert und werden für die weitere Verwendung in Integer umgewandelt, wobei die Woche am Sonntag beginnt. Der Sonntag wird also als \texttt{1} gespeichert, der Montag als \texttt{2} und so weiter. 
\subsection{Ermittlung der nächsten Ampel}
Eigene Position - LocationManager, \texttt{LocationListener} liefern auch Geschwindigkeit.\\
Alle LSA in Umgebung geholt\\
diese inkl distanz gespeichert, im objekt speichern\\
wenn welche gespeichert sind nach der distanz gucken/vergleichen, \\
distant wird kleiner + (am nächsten dran) \\
listener setzen und damit mainactivity benachrichtigen, sodass diese aufgabe an speedhandler delegieren kann\\
Wenn distanz wieder größer ist, lsa löschen\\
wenn distanz größer als mindestreichweite ist -- array loschen. \\
\begin{center}
\rule{35em}{0.5pt}
\lstinputlisting[language=Java, firstline=13, lastline=45, caption={GpsTracker.java}, label=lst:gps]{code/gpstracker.java}
\rule{35em}{0.5pt}
\end{center}
Alternative: Straßendaten, routennavigation\\ vorteile, ampel ist sicher, nachteile:
App wird viel größer (mehrere MB),  interaktion einbauen, navigation einbauen etc. 
%
% v = s/t
%
\subsection{Berechnung der Geschwindigkeitsempfehlung}
An dieser Stelle wird die Berechnung der Geschwindigkeitsempfehlung erklärt und im Listing \ref{lst:speed} veranschaulicht.
Sobald alle benötigten Daten bestehend aus aktueller, eigener Position, Entfernung zur nächsten Ampel und deren Signalschaltplan wird die benötigte Geschwindigkeit errechnet, die Ampel bei Grün zu erreichen. Diese Geschwindigkeit wird mit er Formel: 
\[ v = \frac{s}{t_{2} - t_{1}} \]
berechnet, wobei $t_1$ die aktuelle Sekunde und $s$ die Entfernung zur Ampel ist. Bei der Festlegung der Variable $t_2$ wird zwischen den Ampelphasen unterschieden. Zeigt die Ampel Grün, wird der Zeitpunkt, an dem die Ampel auf Rot schaltet eingesetzt, zeigt sie Rot, der Zeitpunkt an dem sie auf Grün umschaltet. Das Verändert die Ergebnisse zugunsten der FahrerInnen. Wenn beispielsweise im Anwendungsfall UC2, bei dem langsamer gefahren werden muss, um die grüne Ampel zu passieren, wird so die Zeitspanne in der die Ampel grün ist abgezogen, und die anzupassende Geschwindigkeit ist weniger kleiner der aktuellen. \\  
Für FahrradfahrerInnen ist die Beschleunigung ebenfalls von nicht geringer Bedeutung, weil sie begrenzt ist. Die Formel für die Beschleunigung lautet:
\[ a = \frac{v}{(t_{2} - t_{1})^{2}} \] 
Die Variable $v$ ist hier die errechnete Empfehlungsgeschwindigkeit.
\begin{center}
\rule{35em}{0.5pt} \lstinputlisting[language=Java, firstline=121, lastline=134,  caption=SpeedHandler.java, label=lst:speed]{code/SpeedHandler.java} \rule{35em}{0.5pt}
\end{center}
Anhand der Ergebnisse wird die \gls{GUI} aktualisiert.\textit{ Da zusätzlich zur Empfehlung der Countdown der Ampel dargestellt wird, geschieht dies jede Sekunde. Dafür wird ein \texttt{Timer} gesetzt, der genau das tut. Da die Methode zur Geschwindigkeitsberechnung aufgerufen wird, sobald sich die eigene Position um \textit{festgelegte Parameter} ändert, ist sicherzustellen, dass nicht mit jedem Aufruf der Methode ein neuer \texttt{Timer} erstellt wird, wurde die boolsche Variable \texttt{run} eingeführt. }\\\\
\textit{Mit Straßendaten = andere Formel notwendig. Winkel / Hügel mit einbeziehen + Erdkugel etc.}
\section{Installationsanleitung}



